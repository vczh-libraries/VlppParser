/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParsingXml.parser.txt
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSING_XML_PARSINGXML_PARSER_AST
#define VCZH_PARSING_XML_PARSINGXML_PARSER_AST

#include "../Parsing.h"
#include "../ParsingDefinitions.h"
#include "../ParsingAutomaton.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
			/// <summary>Token types. Values of enum items will be used in <see cref="vl::regex::RegexToken::token"/>.</summary>
			enum class XmlParserTokenIndex
			{
				/// <summary>Token INSTRUCTION_OPEN: /&lt;/?</summary>
				INSTRUCTION_OPEN = 0,
				/// <summary>Token INSTRUCTION_CLOSE: /?/&gt;</summary>
				INSTRUCTION_CLOSE = 1,
				/// <summary>Token COMPLEX_ELEMENT_OPEN: /&lt;//</summary>
				COMPLEX_ELEMENT_OPEN = 2,
				/// <summary>Token SINGLE_ELEMENT_CLOSE: ///&gt;</summary>
				SINGLE_ELEMENT_CLOSE = 3,
				/// <summary>Token ELEMENT_OPEN: /&lt;</summary>
				ELEMENT_OPEN = 4,
				/// <summary>Token ELEMENT_CLOSE: /&gt;</summary>
				ELEMENT_CLOSE = 5,
				/// <summary>Token EQUAL: /=</summary>
				EQUAL = 6,
				/// <summary>Token NAME: [a-zA-Z0-9:._/-]+</summary>
				NAME = 7,
				/// <summary>Token ATTVALUE: &quot;[^&lt;&gt;&quot;]*&quot;|&apos;[^&lt;&gt;&apos;]*&apos;</summary>
				ATTVALUE = 8,
				/// <summary>Token COMMENT: /&lt;/!--([^/-&gt;]|-[^/-&gt;]|--[^&gt;])*--/&gt;</summary>
				COMMENT = 9,
				/// <summary>Token CDATA: /&lt;/!/[CDATA/[([^/]]|/][^/]]|/]/][^&gt;])*/]/]/&gt;</summary>
				CDATA = 10,
				/// <summary>Token TEXT: ([^&lt;&gt;=&quot;&apos; /r/n/ta-zA-Z0-9:._/-])+|&quot;|&apos;</summary>
				TEXT = 11,
				/// <summary>Discardable token SPACE: /s+</summary>
				SPACE = 12,
			};
			class XmlNode;
			class XmlText;
			class XmlCData;
			class XmlAttribute;
			class XmlComment;
			class XmlElement;
			class XmlInstruction;
			class XmlDocument;

			/// <summary>Base class of XML nodes.</summary>
			class XmlNode abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<XmlNode>
			{
			public:
				/// <summary>Visitor interface for <see cref="XmlNode"/>.</summary>
				class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlText"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlText* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlCData"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlCData* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlAttribute"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlAttribute* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlComment"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlComment* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlElement"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlElement* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlInstruction"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlInstruction* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="XmlDocument"/>.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(XmlDocument* node)=0;
				};

				/// <summary>Accept a visitor to reveal its real type of this strong-typed AST node.</summary>
				/// <param name="visitor">The visitor, one of its <b>Visit</b> method will be called according to the real type of this strong-typed AST node.</param>
				virtual void Accept(XmlNode::IVisitor* visitor)=0;

			};

			/// <summary>Text node.</summary>
			class XmlText : public XmlNode, vl::reflection::Description<XmlText>
			{
			public:
				/// <summary>Content of the text node.</summary>
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlText> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>CData node.</summary>
			class XmlCData : public XmlNode, vl::reflection::Description<XmlCData>
			{
			public:
				/// <summary>Content of the cdata node</summary>
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlCData> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Attribute node.</summary>
			class XmlAttribute : public XmlNode, vl::reflection::Description<XmlAttribute>
			{
			public:
				/// <summary>Attribute name.</summary>
				vl::parsing::ParsingToken name;
				/// <summary>Attribute value.</summary>
				vl::parsing::ParsingToken value;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlAttribute> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Comment node.</summary>
			class XmlComment : public XmlNode, vl::reflection::Description<XmlComment>
			{
			public:
				/// <summary>Content of the comment node.</summary>
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlComment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Element node.</summary>
			class XmlElement : public XmlNode, vl::reflection::Description<XmlElement>
			{
			public:
				/// <summary>Element name of the open element node.</summary>
				vl::parsing::ParsingToken name;
				/// <summary>(Optional): Element name of the closing element node. The name is ignored when serializing XML to text.</summary>
				vl::parsing::ParsingToken closingName;
				/// <summary>Attributes of the element.</summary>
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;
				/// <summary>Sub nodes for element nodes, text nodes, cdata nodes and comment nodes.</summary>
				vl::collections::List<vl::Ptr<XmlNode>> subNodes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlElement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Instruction node.</summary>
			class XmlInstruction : public XmlNode, vl::reflection::Description<XmlInstruction>
			{
			public:
				/// <summary>Name of the instruction.</summary>
				vl::parsing::ParsingToken name;
				/// <summary>Attributes of the instruction.</summary>
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlInstruction> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>XML document node.</summary>
			class XmlDocument : public XmlNode, vl::reflection::Description<XmlDocument>
			{
			public:
				/// <summary>Prologue nodes, for instructions and comments.</summary>
				vl::collections::List<vl::Ptr<XmlNode>> prologs;
				/// <summary>Root element of the XML document.</summary>
				vl::Ptr<XmlElement> rootElement;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlDocument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::parsing::xml::XmlNode)
			DECL_TYPE_INFO(vl::parsing::xml::XmlText)
			DECL_TYPE_INFO(vl::parsing::xml::XmlCData)
			DECL_TYPE_INFO(vl::parsing::xml::XmlAttribute)
			DECL_TYPE_INFO(vl::parsing::xml::XmlComment)
			DECL_TYPE_INFO(vl::parsing::xml::XmlElement)
			DECL_TYPE_INFO(vl::parsing::xml::XmlInstruction)
			DECL_TYPE_INFO(vl::parsing::xml::XmlDocument)
			DECL_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::parsing::xml::XmlNode::IVisitor)
				void Visit(vl::parsing::xml::XmlText* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlCData* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlAttribute* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlComment* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlElement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlInstruction* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::xml::XmlDocument* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::parsing::xml::XmlNode::IVisitor)

#endif
#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool XmlLoadTypes();
		}
	}
}
#endif