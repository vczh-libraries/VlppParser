/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:ParsingJson.parser.txt
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PARSING_JSON_PARSINGJSON_PARSER_AST
#define VCZH_PARSING_JSON_PARSINGJSON_PARSER_AST

#include "../Parsing.h"
#include "../ParsingDefinitions.h"
#include "../ParsingAutomaton.h"

namespace vl
{
	namespace parsing
	{
		namespace json
		{
			/// <summary>Token types. Values of enum items will be used in <see cref="vl::regex::RegexToken::token"/>.</summary>
			enum class JsonParserTokenIndex
			{
				/// <summary>Token TRUEVALUE: true</summary>
				TRUEVALUE = 0,
				/// <summary>Token FALSEVALUE: false</summary>
				FALSEVALUE = 1,
				/// <summary>Token NULLVALUE: null</summary>
				NULLVALUE = 2,
				/// <summary>Token OBJOPEN: \{</summary>
				OBJOPEN = 3,
				/// <summary>Token OBJCLOSE: \}</summary>
				OBJCLOSE = 4,
				/// <summary>Token ARROPEN: \[</summary>
				ARROPEN = 5,
				/// <summary>Token ARRCLOSE: \]</summary>
				ARRCLOSE = 6,
				/// <summary>Token COMMA: ,</summary>
				COMMA = 7,
				/// <summary>Token COLON: :</summary>
				COLON = 8,
				/// <summary>Token NUMBER: [\-]?\d+(.\d+)?([eE][+\-]?\d+)?</summary>
				NUMBER = 9,
				/// <summary>Token STRING: &quot;([^\\&quot;]|\\[^u]|\\u\d{4})*&quot;</summary>
				STRING = 10,
				SPACE = 11,
			};
			class JsonNode;
			class JsonLiteral;
			class JsonString;
			class JsonNumber;
			class JsonArray;
			class JsonObjectField;
			class JsonObject;

			/// <summary>Base class of JSON nodes.</summary>
			class JsonNode abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<JsonNode>
			{
			public:
				/// <summary>Visitor interface for <see cref="JsonNode">.</summary>
				class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
				{
				public:
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonLiteral">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonLiteral* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonString">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonString* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonNumber">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonNumber* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonArray">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonArray* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonObjectField">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonObjectField* node)=0;
					/// <summary>A callback that is called if the node accepting this visitor is <see cref="JsonObject">.</summary>
					/// <param name="node">The strong-typed AST node in its real type.</param>
					virtual void Visit(JsonObject* node)=0;
				};

				/// <summary>Accept a visitor to reveal its real type of this strong-typed AST node.</summary>
				/// <param name="visitor">The visitor, one of its <b>Visit</b> method will be called according to the real type of this strong-typed AST node.</param>
				virtual void Accept(JsonNode::IVisitor* visitor)=0;

			};

			/// <summary>Literal value node that is not number or string.</summary>
			class JsonLiteral : public JsonNode, vl::reflection::Description<JsonLiteral>
			{
			public:
				/// <summary>Literal value.</summary>
				enum class JsonValue
				{
					/// <summary>A boolean literal: true.</summary>
					True,
					/// <summary>A boolean literal: false.</summary>
					False,
					/// <summary>A null literal.</summary>
					Null,
				};

				/// <summary>The literal value.</summary>
				JsonValue value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonLiteral> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>String literal value node.</summary>
			class JsonString : public JsonNode, vl::reflection::Description<JsonString>
			{
			public:
				/// <summary>Content of the string literal.</summary>
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonString> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Number literal value node.</summary>
			class JsonNumber : public JsonNode, vl::reflection::Description<JsonNumber>
			{
			public:
				/// <summary>Content of the number literal.</summary>
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonNumber> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Array node.</summary>
			class JsonArray : public JsonNode, vl::reflection::Description<JsonArray>
			{
			public:
				/// <summary>Array elements.</summary>
				vl::collections::List<vl::Ptr<JsonNode>> items;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonArray> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Object property node.</summary>
			class JsonObjectField : public JsonNode, vl::reflection::Description<JsonObjectField>
			{
			public:
				/// <summary>Property name.</summary>
				vl::parsing::ParsingToken name;
				/// <summary>Property value.</summary>
				vl::Ptr<JsonNode> value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObjectField> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			/// <summary>Object node.</summary>
			class JsonObject : public JsonNode, vl::reflection::Description<JsonObject>
			{
			public:
				/// <summary>Object properties.</summary>
				vl::collections::List<vl::Ptr<JsonObjectField>> fields;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObject> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::parsing::json::JsonNode)
			DECL_TYPE_INFO(vl::parsing::json::JsonLiteral)
			DECL_TYPE_INFO(vl::parsing::json::JsonLiteral::JsonValue)
			DECL_TYPE_INFO(vl::parsing::json::JsonString)
			DECL_TYPE_INFO(vl::parsing::json::JsonNumber)
			DECL_TYPE_INFO(vl::parsing::json::JsonArray)
			DECL_TYPE_INFO(vl::parsing::json::JsonObjectField)
			DECL_TYPE_INFO(vl::parsing::json::JsonObject)
			DECL_TYPE_INFO(vl::parsing::json::JsonNode::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::parsing::json::JsonNode::IVisitor)
				void Visit(vl::parsing::json::JsonLiteral* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::json::JsonString* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::json::JsonNumber* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::json::JsonArray* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::json::JsonObjectField* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::parsing::json::JsonObject* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::parsing::json::JsonNode::IVisitor)

#endif
			/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
			extern bool JsonLoadTypes();
		}
	}
}
#endif